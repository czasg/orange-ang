---
title: 切片
slug: /basics/slice
---

import FullScreenImage from '@site/src/components/FullScreenImage';
import BrowserWindow from '@site/src/components/BrowserWindow';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<!--package-->

在 Go 中，切片（slice）是一种动态数组，其长度大小可以动态变化，当切片的长度超出了其容量时，切片会自动扩容。因此开发者可以很方便的对切片进行追加、截取等操作。

一个简单的切片定义如下：

```go
var strSlice  = []string{"Alice", "Bob", "Carry", "Dada"}
intSlice := []int{10, 11, 12, 13, 14, 15, 16, 17, 18, 19}
```

在上述代码中，我们初始化了`strSlice`、`intSlice`两个切片。（这里分别使用了`var`和简短声明两种方式。）

除了上述这种直接声明的方式之外，切片还可以使用**make**、**new**的方式进行初始化。

大多数场景下我们可以直接声明使用，有些特殊优化的场景，我们可以使用`make`进行初始化，`new`一般不用。

## 切片初始化

### 直接声明

在 Go 中，切片的基本结构如下：
```go
[]中括号 + 数据类型 + {}大括号
```

切片结构较为简单，我们可以直接声明使用。

```go
intSlice := []int{1, 2, 3}
```

### make

在 Go 中，切片拥有**长度**和**容量**两个重要属性。其中：

- 长度：表示当前切片的实际长度。可以通过内置函数`len`查看切片实际长度。
- 容量：表示当前切片的最大长度。可以通过内置函数`cap`查看切片实际容量。当切片长度达到最大容量时，继续往切片追加元素则会触发扩容。

示例如下：

```go
intSlice := []int{1, 2, 3}
fmt.Println(len(intSlice), cap(intSlice)) // 3 3
```
在上述切片中，我们可以简单的推断该切片长度为3。那切片的容量是多少呢？

对于直接声明的切片而言，切片长度和容量在声明时就确定，并且是相等的。因此上述切片的长度和容量都是3。

在 Go 中，提供内置函数`make`来初始化切片。make的基本结构如下

```go
make([]int, 长度值, 容量值)
```
我们可以看到，使用make初始化切片时需要指定切片类型，此外，还提供了两个参数，用于确认切片的长度和容量。

为什么需要初始化不同的长度和容量？直接使用简短声明不好吗？

在大多数时候确实如实，但是在计算机中，预先分配资源会比临时分配资源更高效。

也就是说，如果已知有1万个元素。那么直接初始化容量为1万，就可以确保切片使用过程中不会触发扩容。相反，如果让切片从0开始使用，那么在实际使用过程中，可能会触发多次扩容，进而影响程序效率。


### new与make区别
略


## 切片操作

### 下标

使用下标可以在切片中唯一指定一个元素。

```go
age := []int{10, 11, 12, 13}
index := 0
// 读取
indexValue := age[index]
fmt.Println(indexValue)
// 更新
age[0] = 123 // 此时值变为 {123, 13, 15, 11}
```

在上述代码中，我们通过下标获取指定位置的值。

虽然切片的使用非常简单，但在使用切片的过程中，需要特别注意**下标越界问题**。

下标越界即当访问的下标大于等于切片长度的时候，程序会panic（崩溃）。你可能会好奇为什么等于切片长度的时候也会panic呢？因为切片的下标是从0开始计算的，因此最大下标是实际长度减一。

```go
age := []int{10, 11, 12, 13}
age[3] // 输出11
age[4] // 下标越界，程序panic
```

### 追加

使用`append`可以在切片中追加元素。使用的方式为`append(原切片, 元素1, 元素2...)`，然后返回新的切片。

```go
age := []int{10, 11, 12, 13}
age = append(age, 123, 123)
fmt.Println(age) // {12, 13, 15, 11, 123, 123}
```

### 截取

截取是切片的特色功能，它支持在一个切片的基础之上，进行裁剪截断，从而返回一个新的切片。

截取的方式是通过下标进行截取的。格式为`[起始下标(包含):结束下标(不包含):容量]`，其中需要注意起始下标和结束下标之间的包含区别，此外还有第三个参数容量，这会在教程底部的进阶中介绍，可以暂时不关注。

```go
age := []int{10, 11, 12, 13}
arr1 := age[0:2] // {12, 13}
arr2 := age[1:3] // {13, 13}
```


### 遍历

```go
for index, name := range home {
    fmt.Printf("序号：%d/姓名：%s", index, name)
}
```

## 进阶-切片扩容原理

切片容量小于 1024 直接翻倍，大于 1024 则扩容 1/4。
```go title="src/runtime/slice.go"
func growslice(et *_type, old slice, cap int) slice {
    ...
	newcap = old.cap
	doublecap := newcap + newcap
	if cap > doublecap {
		newcap = cap
	} else {
		if old.cap < 1024 { // 小于 1024 直接翻倍
			newcap = doublecap
		} else {
			for 0 < newcap && newcap < cap { // 大于 1024 则扩容 1/4
				newcap += newcap / 4
			}
			if newcap <= 0 {
				newcap = cap
			}
		}
	}
	...
}
```


