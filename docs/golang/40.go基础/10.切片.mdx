---
title: 切片
slug: /basics/slice
---

import FullScreenImage from '@site/src/components/FullScreenImage';
import BrowserWindow from '@site/src/components/BrowserWindow';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<!--package-->

在 Go 中，切片是常见的数据类型，它定义了一批同类型的数据集合，开发者可以对集合进行追加、截取等操作。一个简单的切片定义如下：

```go
var name  = []string{"Alice", "Bob", "Carry", "Dada"}
age := []int{10, 11, 12, 13, 14, 15, 16, 17, 18, 19}
```

在上述代码中，我们初始化了`home`、`age`两个切片，分别记录了姓名和年纪两个属性。（不用在意切片长度为什么不一样，只是举个例子~）

切片的初始化有多种方式，包括：**make**、**new**、**直接声明**等方式。大多数场景下我们可以直接声明使用，有些特殊优化的场景，我们可以使用`make`进行初始化，本篇教程使用直接声明的方式。


## 下标

使用下标可以在切片中唯一指定一个元素。

```go
age := []int{10, 11, 12, 13}
index := 0
// 读取
indexValue := age[index]
fmt.Println(indexValue)
// 更新
age[0] = 123 // 此时值变为 {123, 13, 15, 11}
```

在上述代码中，我们通过下标获取指定位置的值。

虽然切片的使用非常简单，但在使用切片的过程中，需要特别注意**下标越界问题**。

下标越界即当访问的下标大于等于切片长度的时候，程序会panic（崩溃）。你可能会好奇为什么等于切片长度的时候也会panic呢？因为切片的下标是从0开始计算的，因此最大下标是实际长度减一。

```go
age := []int{10, 11, 12, 13}
age[3] // 输出11
age[4] // 下标越界，程序panic
```

## 追加

使用`append`可以在切片中追加元素。使用的方式为`append(原切片, 元素1, 元素2...)`，然后返回新的切片。

```go
age := []int{10, 11, 12, 13}
age = append(age, 123, 123)
fmt.Println(age) // {12, 13, 15, 11, 123, 123}
```

## 截取

截取是切片的特色功能，它支持在一个切片的基础之上，进行裁剪截断，从而返回一个新的切片。

截取的方式是通过下标进行截取的。格式为`[起始下标(包含):结束下标(不包含):容量]`，其中需要注意起始下标和结束下标之间的包含区别，此外还有第三个参数容量，这会在教程底部的进阶中介绍，可以暂时不关注。

```go
age := []int{10, 11, 12, 13}
arr1 := age[0:2] // {12, 13}
arr2 := age[1:3] // {13, 13}
```


## 遍历

```go
for index, name := range home {
    fmt.Printf("序号：%d/姓名：%s", index, name)
}
```

## 进阶-切片底层原理

