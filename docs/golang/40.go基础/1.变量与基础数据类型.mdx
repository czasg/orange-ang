---
title: 变量与基础数据类型
slug: /basics/variable-and-data-type
---

import FullScreenImage from '@site/src/components/FullScreenImage';
import BrowserWindow from '@site/src/components/BrowserWindow';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<!--package-->

## 变量
在数学中，我们经常会`假设变量x ...`，这里 `x` 代表了一个可变化的值。

在计算机编程中，变量同样代表了一个可变化的值，通常用于标识和引用内存中的对象。

在 Go 语言中，变量需要先进行申明定义，才可以使用。如果直接使用未定义的变量，则编译器会报错。

变量的声明方式有两种：
- 一种是使用`var`关键字声明变量
- 一种是使用简短声明变量

<BrowserWindow>
    <Tabs>
        <TabItem value="apple" label="var申明变量" default>

            ```go title="申明变量类型不赋值"
            var key string
            key = "字符串变量"
            ```
            ```go title="申明变量同时赋值，可以不指定变量类型"
            var key = "字符串变量"
            ```
            使用`var`关键字声明变量时，可以只声明而不赋值。

        </TabItem>
        <TabItem value="orange" label="简短申明变量">

            ```go title="简短申明"
            key := "字符串变量"
            ```
            使用短声明方式则需要指定初始值。

        </TabItem>
    </Tabs>
</BrowserWindow>


## 整数类型

在 Go 语言中，整数类型包含：

- **int**：表示有符号整数，其大小可以是32位或64位，具体取决于所运行的平台。
- **uint**：表示无符号整数，其大小也可以是32位或64位，取决于所运行的平台。
- **int8、int16、int32、int64**：分别表示8位、16位、32位和64位的有符号整数。
- **uint8、uint16、uint32、uint64**：分别表示8位、16位、32位和64位的无符号整数。

整数默认是`int`类型。

这些整数类型主要的区别就是精度范围不同，不同的精度范围所需要的存储空间不同，因此在使用整数类型时，可以根据需求选择合适的整数类型。

需要注意：

- 在数值上，不同的整数类型值范围不同。
```js
int8  // -128~127
int16 // -32768~32767
int32 // -2147483648~2147483647
int64 // -9223372036854775808~9223372036854775807
```
- 在存储上，不同的整数类型存储大小不同。
```js
int8  // 1字节
int16 // 2字节
int32 // 4字节
int64 // 8字节
```
- 在计算上，超过精度范围，会**发生溢出**，导致整数类型循环（回到相反的极值）。
```go
package main

import "fmt"

func main() {
    var x int8 = 127 // -128~127
    x++
    fmt.Println(x) // -128
}
```
- 在使用上，需要注意它们之间不能直接替换。如果不同整数类型之间要进行计算，则可以通过强制类型转化。尤其要**注意溢出问题**。


<Tabs>
    <TabItem value="apple1" label="类型转化" default>

        ```go
        package main

        func main() {
            var x int = 1
            var y int64 = 0
            y = int64(x) + 1
        }
        ```

    </TabItem>
    <TabItem value="orange2" label="转化溢出">

        ```go
        package main

        import "fmt"

        func main() {
            var x int16 = 128
            fmt.Println(int8(x)) // -128

            var y int16 = 129
            fmt.Println(int8(y)) // -127
        }
        ```

    </TabItem>
</Tabs>


## 浮点数类型

:::tip 请思考
在 Go 中，为什么 0.1+0.2 不等于 0.3？
:::

在计算机中，一般使用科学计数法来表示小数。科学计数法由符号位、指数位和小数位三部分组成。 <br/>
为了更好地进行存储和计算，计算机使用浮点数来表示科学计数值。因此，在计算机中，小数的表示通常会存在一定程度的精度损失问题。

这意味着，某些看似简单的小数值，例如0.1，可能不会精确地等于0.1，而是等于0.10000000001之类的值。这是因为计算机中浮点数的表示方式所导致的，浮点数的精度有限，无法精确表示所有的小数值。

在 Go 语言中，浮点数类型包含：

- **float32**：单精度浮点数，占用32位，用于表示小数。
- **float64**：双精度浮点数，占用64位，用于表示小数。

浮点数在Go语言中默认为`float64`类型。这些浮点数类型的主要区别在于精度范围的不同，但无论是哪种类型的浮点数，都存在精度损失问题。

```go title="浮点数精度损失"
package main

import "fmt"

func main() {
    x := 0.1
    y := 0.2
    z := 0.3

    sum := x + y

    // 浮点数精度损失导致 0.3 不等于 0.3
    fmt.Println(sum == z) // false
}
```

## 布尔类型

在 Go 语言中，布尔类型`bool`只有`true`和`false`两个取值。

声明`bool`变量时，默认为`false`。
```go
var isBool bool // false
```

## 字符串

在 Go 中，我们通常使用双引号和反引号来表示字符串。

- **双引号**（""）：用于表示普通的字符串文字，它们可以包含转义字符，例如 `\n` 表示换行符。
- **反引号**（``）：用于表示原始字符串文本，它会保留字符串中的换行符和其他特殊字符，不会进行转义处理。

下面通过一个示例展示区别：

```go
str := "这是一个字符串\n这是一个换行符"
rawStr := `
这是一个字符串\n
这是一个换行符
`
```

在这个示例中，`str`中的`\n`会转义成换行，而`rawStr`中的`\n`会以字符串的形式保留下来。


## byte

在 Go 中，`byte`类型通常用于处理字节数据和二进制数据，同时也可以用于表示ASCII字符。

在 Go 源码中，我们可以看到`byte`的定义：
```go title="https://github.com/golang/go/blob/master/src/builtin/builtin.go"
type byte = uint8
```
这意味着在 Go 中，`byte`类型底层实际上是`uint8`类型的别名。 <br/>
因此，`byte`类型可以表示一个8位的无符号整数，取值范围在0~255。这正好对应着一个ASCII字符的表示，而且占用大小为1个字节。

另外，`string`底层基于`[]byte`实现。因此两者之间支持相互转化。例如：

```go title="字符串和字节数组之间的转换"
str := "hello"
byteSlice := []byte(str) // 将字符串转换为字节数组
fmt.Println(byteSlice)   // [104 101 108 108 111]

str2 := string(byteSlice) // 将字节数组转换为字符串
fmt.Println(str2)         // hello
```

正是因为这个特性，使得在 Go 中计算字符串长度时需要注意一些坑点。

例如在处理非ASCII字符时，每个字符可能占据多个字节的存储空间，这可能导致使用内置的`len()`函数得到的长度与我们期望的不符：

```go title="中文字符长度计算异常"
name := "橙子昂"
fmt.Println(len(name)) // 9
```

在这个示例中，由于`name`变量中包含了中文字符，每个中文字符需要3~4个字节表示，因此，使用内置的`len()`函数计算字符串长度时得到的结果是9，而不是我们正常认知的3。

如果要正确计算包含非ASCII字符的字符串长度，我们需要将其转化为`rune`类型，然后再计算其长度。


## rune

在 Go 中，`rune`类型通常用于表示Unicode字符。

:::tip 什么是 Unicode 字符？

在计算机早期阶段，只有ASCII字符集。由于当时计算机主要是处理英文文本，因此ASCII字符集足够满足编码需求。

然而，随着全球信息化的发展，不同国家和地区的语言、符号、标点等多样性需求迅速增加，ASCII已经无法满足这种多元化的字符集需求。

为了解决这一问题，Unicode字符集应运而生。

Unicode字符集被认为是当前世界上最全的字符编码集合，涵盖了几乎全球范围内所有的字符，从简单的拉丁字母到复杂的表意文字，无论是哪种语言、符号或标点，都能在Unicode中找到相应的表示。
正因如此，Unicode已成为全球化文本处理的标准。

:::

:::tip 什么是 UTF-8/UTF-32 编码？

URF-8 是 Unicode 字符集的一种实现，它采用可变长度的编码方案。 <br/>
在实际编码中，它以一种节省空间的方式处理字符：
- 对于 ASCII 字符，UTF-8 使用单个字节进行编码，
- 对于其他字符，UTF-8 则使用多个字节，最多可达到4个字节。

URF-32 也是 Unicode 字符集的一种实现，但它采用固定长度的编码方案。 <br/>
在实际编码中，UTF-32 使用固定的32位长度来表示每个字符。即使是仅占用1字节的 ASCII 字符，UTF-32 也会使用4字节来表示，这使得它在存储上显得相对笨重，但更为简单。

:::

在 Go 源码中，我们可以看到`rune`的定义：
```go title="https://github.com/golang/go/blob/master/src/builtin/builtin.go"
type rune = int32
```

这意味着在 Go 中，`rune`类型底层实际上是`int32`类型的别名。
因此，`rune`类型可以表示一个32位的有符号整数，而且占用大小为1个字节。

另外，string底层基于[]byte实现。因此两者之间支持相互转化。例如：
