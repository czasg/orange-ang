---
title: 变量与基础类型
slug: /basics/variable-and-data-type
---

import FullScreenImage from '@site/src/components/FullScreenImage';
import BrowserWindow from '@site/src/components/BrowserWindow';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<!--package-->

## 变量
在数学中，我们经常会`假设变量x ...`，这里 `x` 代表了一个可变化的值。

在计算机编程中，变量同样代表了一个可变化的值，通常用于标识和引用内存中的对象。

在 Go 语言中，变量的声明方式有两种：

- 使用`var`关键字声明变量，语法结构为 `var 变量名 数据类型`
- 使用**简短声明**变量，语法结构为 `变量名 := 数据值`

变量需要先进行申明定义，才可以使用。如果直接使用未定义的变量，编译器会抛出报错。

<BrowserWindow>
    <Tabs>
        <TabItem value="apple" label="var申明变量" default>

            使用`var`关键字声明变量时，可以只声明而不赋值，也可以声明时直接赋值。区别就是后者可以不指定数据类型。
            ```go title="申明变量类型不赋值"
            var key string
            key = "字符串变量"
            ```
            ```go title="申明变量同时赋值，可以不指定变量类型，由程序自动识别类型"
            var key = "字符串变量"
            ```

        </TabItem>
        <TabItem value="orange" label="简短申明变量">

            使用短声明方式则需要指定初始值。但简短申明不需要指定变量类型，由程序自动识别类型。
            ```go
            key := "字符串变量"
            ```

        </TabItem>
    </Tabs>
</BrowserWindow>


## 整数类型

在 Go 语言中，整数类型包含：

- **int**：表示有符号整数，其大小可以是32位或64位，具体取决于所运行的平台。
- **uint**：表示无符号整数，其大小也可以是32位或64位，取决于所运行的平台。
- **int8、int16、int32、int64**：分别表示8位、16位、32位和64位的有符号整数。
- **uint8、uint16、uint32、uint64**：分别表示8位、16位、32位和64位的无符号整数。

使用简短声明的数字默认是`int`类型。

```go
value := 1 // int
```

如果需要其他整数类型，则需要使用`var`关键字声明，或者使用**数据类型转化**。

```go
var value64 int64 = 1 // int64

value64 := int64(1) // int64 - 数据类型转化
```

这些整数类型主要的区别就是精度（取值）范围不同，不同的精度范围所需要的存储空间也是不同的，因此在使用整数类型时，可以根据需求选择合适的整数类型。

简单总结下，在使用整数类型时，需要注意以下几点：

1. 在数值上，不同的整数类型值范围不同。
```js
int8  // -128~127
int16 // -32768~32767
int32 // -2147483648~2147483647
int64 // -9223372036854775808~9223372036854775807
```
2. 在存储上，不同的整数类型存储大小不同。
```js
int8  // 1字节
int16 // 2字节
int32 // 4字节
int64 // 8字节
```
3. 在计算上，超过精度范围，会**发生溢出**，导致整数类型循环（回到相反的极值）。
```go
package main

import "fmt"

func main() {
    var x int8 = 127 // -128~127
    x++
    fmt.Println(x) // -128！！！
}
```
4. 类型转化（大转小）需要**注意溢出问题**。
```go
package main

import "fmt"

func main() {
    var x int16 = 128
    fmt.Println(int8(x)) // -128！！！

    var y int16 = 129
    fmt.Println(int8(y)) // -127！！！
}
```


## 浮点数类型

浮点数即我们理解的数学概念中的小数，比如无限不循环小数 π 3.14159...

在计算机中，小数一般使用科学计数法来表示，而科学计数法存在精度损失问题，因为他是一个近似值计算。

这代表什么意思呢？

也就是说，我们认为的 `0.1`，在计算机中可能是由 `0.10000000001` 近似得来的。因此在计算机编程中，使用浮点数来进行对比计算时需要特别小心，因为很有可能就出现 `0.1 + 0.2 != 0.3` 的情况。


```go title="0.1 + 0.2 != 0.3"
package main

import "fmt"

func main() {
    x := 0.1
    y := 0.2
    z := 0.3

    sum := x + y // 0.3

    isEqual := sum == z  // 浮点数精度损失导致 0.3 不等于 0.3
    fmt.Println(isEqual) // false
}
```

在 Go 语言中，浮点数类型包含：

- **float32**：单精度浮点数，占用32位，用于表示小数。
- **float64**：双精度浮点数，占用64位，用于表示小数。

使用简短声明的数字默认是`float64`类型。

```go
value := 3.14159 // float64
```

如果需要其他浮点数类型，则需要使用`var`关键字声明，或者使用**数据类型转化**。

```go
var value64 float32 = 3.14159 // float32

value64 := float32(3.14159) // float32 - 数据类型转化
```

这些浮点数类型的主要区别在于精度范围的不同，但无论是哪种类型的浮点数，都存在精度损失问题。

## bool

在 Go 语言中，布尔类型`bool`只有`true`和`false`两个取值。

使用`var`声明`bool`变量时，默认为`false`。
```go
var isEqual bool // false
```

## string

在 Go 语言中，字符串类型`string`有两种表示方式：

- **双引号**（""）：用于表示**普通的字符串文字**，它们可以包含转义字符，例如 `\n` 表示换行符。
- **反引号**（``）：用于表示**原始字符串文本**，它会保留字符串中的换行符和其他特殊字符，不会进行转义处理。

下面通过两个示例展示区别：

```go
commonStr := "这是一个普通字符串 \n 这里有一个换行符"
```

在这个示例中，`commonStr`中的`\n`会转义成换行符，因此展示上会有两行。

```go
rawStr := `这是一个原始字符串 \n 这里有一个换行符字串`
```

在这个示例中，`rawStr`中的`\n`会以字符串的形式保留下来，因此展示上只有一行。


## byte

在 Go 语言中，字节类型`byte`通常用于处理字节数据和二进制数据，同时也可以用于表示ASCII字符。

我们可以通过go源码了解`byte`的定义：
```go title="https://github.com/golang/go/blob/master/src/builtin/builtin.go"
type byte = uint8
```
在上述源码中，我们可以看到`byte`类型底层实际上是`uint8`类型的别名。

这意味着在go中，`byte`类型可以表示一个8位的无符号整数，取值范围在0~255，这正好对应着一个ASCII字符的范围，因此`byte`可以用于表示ASCII字符。

此外，要特别注意go中`string`的一个坑点，这里放在`byte`章节介绍是因为`string`底层由字节数组`[]byte`实现数据存储。

基于这个特性，所以`string`与`[]byte`之间可以直接相互转化。但也为字符串长度计算埋下了坑点！

我们先通过一个示例来看下`string`与`[]byte`之间如何进行相互转化。

```go
str := "hello"

byteSlice := []byte(str)      // 将字符串转换为字节数组
fmt.Println(byteSlice)        // [104 101 108 108 111]
fmt.Println(len(byteSlice))   // 长度为5

str2 := string(byteSlice) // 将字节数组转换为字符串
fmt.Println(str2)         // hello
fmt.Println(str2)         // 长度为5
```

在这个示例中，我们可以看到`str`和`byteSlice`之间可以相互转化，并且长度都是5！

但是，当我们换一个中文时，诡异的事情就发生了！

```go
name := "橙子昂"
fmt.Println(len(name)) // 9
```

在上述示例中，我们想当然的认为`name`长度就是3，但是在go中这段代码会诡异的输出9！

这是因为中文通常需要使用3个字节来表示，因此`name`底层实际是`[230 169 153 229 173 144 230 152 130]`，而这个数组长度正好为9~

如果要正确计算包含非ASCII字符的字符串长度，我们需要将其转化为`rune`类型，然后再计算其长度。

## rune

在 Go 中，`rune`类型通常用于表示Unicode字符。

:::tip 什么是 Unicode 字符？

在计算机早期阶段，只有ASCII字符集。由于当时计算机主要是处理英文文本，因此ASCII字符集足够满足编码需求。

然而，随着全球信息化的发展，不同国家和地区的语言、符号、标点等多样性需求迅速增加，ASCII已经无法满足这种多元化的字符集需求。

为了解决这一问题，Unicode字符集应运而生。

Unicode字符集被认为是当前世界上最全的字符编码集合，涵盖了几乎全球范围内所有的字符，从简单的拉丁字母到复杂的表意文字，无论是哪种语言、符号或标点，都能在Unicode中找到相应的表示。
正因如此，Unicode已成为全球化文本处理的标准。

:::

:::tip 什么是 UTF-8 编码？

URF-8 是 Unicode 字符集的一种实现，它采用可变长度的编码方案。 <br/>
在实际编码中，它以一种节省空间的方式处理字符：
- 对于 ASCII 字符，UTF-8 使用单个字节进行编码，
- 对于其他字符，UTF-8 则使用多个字节，最多可达到4个字节。

:::

:::tip 什么是 UTF-32 编码？

URF-32 也是 Unicode 字符集的一种实现，但它采用固定长度的编码方案。 <br/>
在实际编码中，UTF-32 使用固定的32位长度来表示每个字符。即使是仅占用1字节的 ASCII 字符，UTF-32 也会使用4字节来表示，这使得它在存储上显得相对笨重，但更为简单。

:::

在 Go 源码中，我们可以看到`rune`的定义：
```go title="https://github.com/golang/go/blob/master/src/builtin/builtin.go"
type rune = int32
```

我们可以看到，`rune` 类型实际上是 `int32` 类型的别名。 <br/>
因此 `rune` 类型可以表示一个32位的有符号整数，占用大小为4个字节。由于这样的特性，`rune` 类型非常适合表示 Unicode 编码。
